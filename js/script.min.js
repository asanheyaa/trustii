const burgerMenu = document.querySelector(".burger-menu"), header = document.querySelector(".header"), menu = document.querySelector(".header__menu-wrapper"); function dynamicAdaptiv() { new class { constructor(e) { this.type = e } init() { this.оbjects = [], this.daClassname = "_dynamic_adapt_", this.nodes = [...document.querySelectorAll("[data-da]")], this.nodes.forEach((e => { const t = e.dataset.da.trim().split(","), n = {}; n.element = e, n.parent = e.parentNode, n.destination = document.querySelector(`${t[0].trim()}`), n.breakpoint = t[1] ? t[1].trim() : "767", n.place = t[2] ? t[2].trim() : "last", n.index = this.indexInParent(n.parent, n.element), this.оbjects.push(n) })), this.arraySort(this.оbjects), this.mediaQueries = this.оbjects.map((({ breakpoint: e }) => `(${this.type}-width: ${e}px),${e}`)).filter(((e, t, n) => n.indexOf(e) === t)), this.mediaQueries.forEach((e => { const t = e.split(","), n = window.matchMedia(t[0]), i = t[1], s = this.оbjects.filter((({ breakpoint: e }) => e === i)); n.addEventListener("change", (() => { this.mediaHandler(n, s) })), this.mediaHandler(n, s) })) } mediaHandler(e, t) { e.matches ? t.forEach((e => { this.moveTo(e.place, e.element, e.destination) })) : t.forEach((({ parent: e, element: t, index: n }) => { t.classList.contains(this.daClassname) && this.moveBack(e, t, n) })) } moveTo(e, t, n) { t.classList.add(this.daClassname), "last" === e || e >= n.children.length ? n.append(t) : "first" !== e ? n.children[e].before(t) : n.prepend(t) } moveBack(e, t, n) { t.classList.remove(this.daClassname), void 0 !== e.children[n] ? e.children[n].before(t) : e.append(t) } indexInParent(e, t) { return [...e.children].indexOf(t) } arraySort(e) { "min" === this.type ? e.sort(((e, t) => e.breakpoint === t.breakpoint ? e.place === t.place ? 0 : "first" === e.place || "last" === t.place ? -1 : "last" === e.place || "first" === t.place ? 1 : 0 : e.breakpoint - t.breakpoint)) : e.sort(((e, t) => e.breakpoint === t.breakpoint ? e.place === t.place ? 0 : "first" === e.place || "last" === t.place ? 1 : "last" === e.place || "first" === t.place ? -1 : 0 : t.breakpoint - e.breakpoint)) } }("max").init() } burgerMenu.addEventListener("click", (e => { burgerMenu.classList.toggle("_active"), menu.classList.toggle("_active"), document.body.classList.toggle("_lock"), header.classList.toggle("_open-menu") })), dynamicAdaptiv(); const menuLinks = document.querySelectorAll(".header-menu__link"); menuLinks && menuLinks.forEach((e => { e.addEventListener("click", (function (t) { if (t.preventDefault(), "true" === document.documentElement.dataset.mobileMode) { const t = e.nextElementSibling; e.classList.toggle("_active"), function (e, t = 500) { if ("none" === window.getComputedStyle(e).display) return function (e, t = 500) { if (!e.classList.contains("_slide")) { e.classList.add("_slide"), e.style.removeProperty("display"); let n = window.getComputedStyle(e).display; "none" === n && (n = "block"), e.style.display = n; let i = e.offsetHeight; e.style.overflow = "hidden", e.style.height = 0, e.style.paddingTop = 0, e.style.paddingBottom = 0, e.style.marginTop = 0, e.style.marginBottom = 0, e.offsetHeight, e.style.transitionProperty = "height, margin, padding", e.style.transitionDuration = t + "ms", e.style.height = i + "px", e.style.removeProperty("padding-top"), e.style.removeProperty("padding-bottom"), e.style.removeProperty("margin-top"), e.style.removeProperty("margin-bottom"), window.setTimeout((() => { e.style.removeProperty("height"), e.style.removeProperty("overflow"), e.style.removeProperty("transition-duration"), e.style.removeProperty("transition-property"), e.classList.remove("_slide") }), t) } }(e, t); !function (e, t = 500) { e.classList.contains("_slide") || (e.classList.add("_slide"), e.style.transitionProperty = "height, margin, padding", e.style.transitionDuration = t + "ms", e.style.height = e.offsetHeight + "px", e.offsetHeight, e.style.overflow = "hidden", e.style.height = 0, e.style.paddingTop = 0, e.style.paddingBottom = 0, e.style.marginTop = 0, e.style.marginBottom = 0, window.setTimeout((() => { e.style.display = "none", e.style.removeProperty("height"), e.style.removeProperty("padding-top"), e.style.removeProperty("padding-bottom"), e.style.removeProperty("margin-top"), e.style.removeProperty("margin-bottom"), e.style.removeProperty("overflow"), e.style.removeProperty("transition-duration"), e.style.removeProperty("transition-property"), e.classList.remove("_slide") }), t)) }(e, t) }(t) } })) })); let mql = window.matchMedia("(max-width: 991.98px)"); function mobileModeFunction() { mql.matches ? document.documentElement.dataset.mobileMode = !0 : document.documentElement.dataset.mobileMode = !1 } window.addEventListener("resize", mobileModeFunction), mobileModeFunction(); const headerChanging = document.querySelector(".header-changing"); if (headerChanging) { function onScrollFunction(e) { (document.documentElement.scrollTop || document.body.scrollTop) > 10 ? header.classList.add("_active") : header.classList.remove("_active") } window.addEventListener("scroll", onScrollFunction) } const MatchMedia = { mobile: window.matchMedia("(width <= 797.98px)") }; class BaseComponent { constructor() { if (this.constructor === BaseComponent) throw new Error("Невозможно создать экземпляр абстрактного класса BaseComponent!") } getProxyState(e) { return new Proxy(e, { get: (e, t) => e[t], set: (e, t, n) => { const i = e[t]; return e[t] = n, n !== i && this.updateUI(), !0 } }) } updateUI() { throw new Error("Необходимо реализовать метод updateUI!") } } const rootSelector = "[data-js-select]"; class Select extends BaseComponent { selectors = { root: rootSelector, originalControl: "[data-js-select-original-control]", button: "[data-js-select-button]", dropdown: "[data-js-select-dropdown]", option: "[data-js-select-option]" }; stateClasses = { isExpanded: "is-expanded", isSelected: "is-selected", isCurrent: "is-current", isOnTheLeftSide: "is-on-the-left-side", isOnTheRightSide: "is-on-the-right-side" }; stateAttributes = { ariaExpanded: "aria-expanded", ariaSelected: "aria-selected", ariaActiveDescendant: "aria-activedescendant" }; initialState = { isExpanded: !1, currentOptionIndex: null, selectedOptionElement: null }; constructor(e) { super(), this.rootElement = e, this.originalControlElement = this.rootElement.querySelector(this.selectors.originalControl), this.buttonElement = this.rootElement.querySelector(this.selectors.button), this.dropdownElement = this.rootElement.querySelector(this.selectors.dropdown), this.optionElements = this.dropdownElement.querySelectorAll(this.selectors.option), this.state = this.getProxyState({ ...this.initialState, currentOptionIndex: this.originalControlElement.selectedIndex, selectedOptionElement: this.optionElements[this.originalControlElement.selectedIndex] }), this.fixDropdownPosition(), this.updateTabIndexes(), this.bindEvents() } updateUI() { const { isExpanded: e, currentOptionIndex: t, selectedOptionElement: n } = this.state, i = n.textContent.trim(); (() => { this.originalControlElement.value = i })(), (() => { this.buttonElement.textContent = i, this.buttonElement.classList.toggle(this.stateClasses.isExpanded, e), this.buttonElement.setAttribute(this.stateAttributes.ariaExpanded, e), this.buttonElement.setAttribute(this.stateAttributes.ariaActiveDescendant, this.optionElements[t].id) })(), (() => { this.dropdownElement.classList.toggle(this.stateClasses.isExpanded, e) })(), (() => { this.optionElements.forEach(((e, i) => { const s = t === i, o = n === e; e.classList.toggle(this.stateClasses.isCurrent, s), e.classList.toggle(this.stateClasses.isSelected, o), e.setAttribute(this.stateAttributes.ariaSelected, o) })) })() } toggleExpandedState() { this.state.isExpanded = !this.state.isExpanded } expand() { this.state.isExpanded = !0 } collapse() { this.state.isExpanded = !1 } fixDropdownPosition() { const e = document.documentElement.clientWidth / 2, { width: t, x: n } = this.buttonElement.getBoundingClientRect(), i = n + t / 2 < e; this.dropdownElement.classList.toggle(this.stateClasses.isOnTheLeftSide, i), this.dropdownElement.classList.toggle(this.stateClasses.isOnTheRightSide, !i) } updateTabIndexes(e = MatchMedia.mobile.matches) { this.originalControlElement.tabIndex = e ? 0 : -1, this.buttonElement.tabIndex = e ? -1 : 0 } get isNeedToExpand() { const e = document.activeElement === this.buttonElement; return !this.state.isExpanded && e } selectCurrentOption() { this.state.selectedOptionElement = this.optionElements[this.state.currentOptionIndex] } onButtonClick = () => { this.toggleExpandedState() }; onClick = e => { const { target: t } = e, n = t === this.buttonElement, i = t.closest(this.selectors.dropdown) !== this.dropdownElement; if (!n && i) return void this.collapse(); t.matches(this.selectors.option) && (this.state.selectedOptionElement = t, this.state.currentOptionIndex = [...this.optionElements].findIndex((e => e === t)), this.collapse()) }; onArrowUpKeyDown = () => { this.isNeedToExpand ? this.expand() : this.state.currentOptionIndex > 0 && this.state.currentOptionIndex-- }; onArrowDownKeyDown = () => { this.isNeedToExpand ? this.expand() : this.state.currentOptionIndex < this.optionElements.length - 1 && this.state.currentOptionIndex++ }; onSpaceKeyDown = () => { this.isNeedToExpand ? this.expand() : (this.selectCurrentOption(), this.collapse()) }; onEnterKeyDown = () => { this.isNeedToExpand ? this.expand() : (this.selectCurrentOption(), this.collapse()) }; onKeyDown = e => { const { code: t } = e, n = { ArrowUp: this.onArrowUpKeyDown, ArrowDown: this.onArrowDownKeyDown, Space: this.onSpaceKeyDown, Enter: this.onEnterKeyDown }[t]; n && (e.preventDefault(), n()) }; onMobileMatchMediaChange = e => { this.updateTabIndexes(e.matches) }; onOriginalControlChange = () => { this.state.selectedOptionElement = this.optionElements[this.originalControlElement.selectedIndex] }; bindEvents() { MatchMedia.mobile.addEventListener("change", this.onMobileMatchMediaChange), this.buttonElement.addEventListener("click", this.onButtonClick), document.addEventListener("click", this.onClick), this.rootElement.addEventListener("keydown", this.onKeyDown), this.originalControlElement.addEventListener("change", this.onOriginalControlChange) } } class SelectCollection { constructor() { this.init() } init() { document.querySelectorAll(rootSelector).forEach((e => { new Select(e) })) } } new SelectCollection; const animItems = document.querySelectorAll("[data-anim-item]"); if (animItems) { function animOnScroll() { animItems.forEach((e => { const t = e.offsetHeight, n = offset(e).top, i = window.scrollY; let s = window.innerHeight - t / 5; if (t > window.innerHeight && (s = window.innerHeight - window.innerHeight / 5), i > n - s && i < n + t) e.classList.add("_show"); else { 0 === e.dataset.animItem.length && e.classList.remove("_show") } })) } function offset(e) { const t = e.getBoundingClientRect(), n = window.scrollX || document.documentElement.scrollLeft, i = window.scrollY || document.documentElement.scrollTop; return { top: t.top + i, left: t.left + n } } window.addEventListener("scroll", animOnScroll), setTimeout((() => { animOnScroll() }), 300) }